type Potato @model {
  id: ID! @isUnique
  createdAt: DateTime!
  # Every relation also required a back-relation (to determine 1:1, 1:n or n:m)
  createdBy: User! @relation(name: "UserCreatesPotato")
  droppedBy: User @relation(name: "UserDropsPotato")
  holders: [Holder!]! @relation(name: "PotatoHeld")
}

type User @model {
  id: ID! @isUnique
  createdAt: DateTime!

  email: String! @isUnique
  password: String!
  name: String!
  
  create: [Potato!]! @relation(name: "UserCreatesPotato")
  holdings: [Holder!]! @relation(name: "UserHold")
  drops: [Potato!]! @relation(name: "UserDropsPotato")
}

type Holder @model {
  id: ID! @isUnique
  createdAt: DateTime!

  user: User! @relation(name: "UserHold")
  potato: Potato! @relation(name: "PotatoHeld")
  sequence: Int! @default(value: 0)
}